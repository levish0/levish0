---
title: "Data Structure: Sorting"
description: "Process of arranging items or elements in a particular order or sequence"
date: "2023-05-26"
tags: ['data-structure']
---
## Sorting
이 글에서는 대략 8개 정도의 Sorting알고리즘에 대해 다루겠습니다. 각각 
- Binary tree sort
- Bubble sort
- Insertion sort
- Selection sort
- Shell sort
- Quick sort
- Merge sort
- Radix sort  

입니다.

## Binary tree sort
Binary Tree를 그대로 사용하는 것입니다. LNR순서로 순회한다면, 증가 순서로 나오게 될 것이고, RNL순서로 순회한다면 감소순서로 나오게 될 것입니다. 예시로 한 Binary Tree를 들고 오자면, 

<p align="center">
<img src="https://github.com/shiueo/shiueo/blob/main/web/public/Binary_tree_v2.jpg?raw=true"/><br/>
from <a href="https://www.geeksforgeeks.org">geeksforgeeks</a>
</p>

LNR: 4 5 8 11 12 17 18  
RNL: 18 17 12 8 5 4  
순으로 잘 정렬되어 나오는 것을 알 수 있습니다.

## Bubble sort
Bubble sort는 인접한 두개의 원소를 검사하여서 큰 것과의 위치를 swap, 이걸 반복해 가장 큰 원소를 뒤에다 보내놓으면서 정렬하는 방법입니다. 
<p align="center">
<img src="https://github.com/shiueo/shiueo/blob/main/web/public/bubble_sort.gif?raw=true"/><br/>
</p>

Bubble sort는 이렇게 n개의 원소를 정렬한다 하면 n번부터 1번까지 1씩 줄어들며 비교를 해내야 하고 이를 결국 n번 반복해내야 하기 때문에 **Big-O Notation**으로 봤을 때, $O(N^2)$인 것을 알 수 있습니다.

## Insertion sort
Insertion sort는 두번째 값부터 시작해서 그 앞자리것들과 자신을 비교해 만약 자신이 더 작다면 앞자리의 작았던 원소앞에 자신을 밀어넣는 방식으로 진행됩니다. 

<p align="center">
<img src="https://github.com/shiueo/shiueo/blob/main/web/public/insertion_sort.gif?raw=true"/><br/>
</p>

## Selection sort
Selection sort는 가장 작은 값부터 앞으로 놓겠다는 정렬이다. 첫번째 값을 잡고 뒷번 인덱스를 전부 가본 다음 가장 작은 값을 앞으로 끌어와 교환시킵니다.

<p align="center">
<img src="https://github.com/shiueo/shiueo/blob/main/web/public/selection_sort.gif?raw=true"/><br/>
</p>

## Shell sort
Shell sort는 삽입정렬을 보완해낸 알고리즘입니다. 간격을 설정해놓고 이동을 하는데, 이 간격을 $k$라고 한다면, 한번 회전시마다 이를 절반으로 줄여냅니다. (물론 자신이 그 수를 정해버려도 됩니다.) 이때 간격이 홀수면 더 좋기 때문에 반으로 나눠서 홀수에 가까운 쪽으로 보내도록 합니다.

어떤 방식으로 작동하냐면  
| =  | =  |  = | =  | =  |  = | =  |  = |  = | =  | = |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|  10| 8  |  6 |  20 | 4  | 3  |  22 | 1  | 0  | 15  | 16  |

이라는 배열이 있다고 해보면,  


### K = 5
| =  | =  |  = | =  | =  |  = | =  |  = |  = | =  | = |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|  10|   |   |   |   | 3  |   |   |   |   | 16  |
|   | 8  |   |   |   |   | 22  |   |   |   |   |  |
|   |   |  6 |   |   |   |   |   1|   |   |   | |
|   |   |   |  20 |   |   |   |   |  0 |   |   |  |
|   |   |   |   | 4  |   |   |   |   |   15|   | |

5칸씩 밀려서 값들이 들어가게 한 뒤,

같은 vertical line에 있는 값들을 삽입정렬 시킵니다.

| =  | =  |  = | =  | =  |  = | =  |  = |  = | =  | = |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|  3|   |   |   |   | 10  |   |   |   |   | 16  |
|   | 8  |   |   |   |   | 22  |   |   |   |   |  |
|   |   |  1 |   |   |   |   |   6|   |   |   | |
|   |   |   |  0 |   |   |   |   |  20 |   |   |  |
|   |   |   |   | 4  |   |   |   |   |   15|   | |

그 후에 이를 다시 바닥으로 눌러내려주면
| =  | =  |  = | =  | =  |  = | =  |  = |  = | =  | = |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|  3| 8  |  1 |  0 | 4  | 10  |  22 | 6  | 20  | 15  | 16  |

가 됩니다. 이제 이게 1회전 끝이다. 그 다음 K=3입니다.

### K = 3
| =  | =  |  = | =  | =  |  = | =  |  = |  = | =  | = |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|  3|   |   |  0 |   |   | 22  |   |   |  15 |
|   | 8  |   |   | 4  |   |   |  6 |   |   |  16 |
|   |   |  1 |   |   |  10 |   |   | 20  |   |   |

이걸 다시 삽입정렬 하고,

| =  | =  |  = | =  | =  |  = | =  |  = |  = | =  | = |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|  0|   |   |  3 |   |   | 15  |   |   |  22 |
|   | 4  |   |   | 6  |   |   |  8 |   |   |  16 |
|   |   |  1 |   |   |  10 |   |   | 20  |   |   |

찍어 누릅니다.

| =  | =  |  = | =  | =  |  = | =  |  = |  = | =  | = |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|  0| 4  |  1 |  3 | 6  | 10  |  15 | 8  | 20  | 22  | 16  |

이제 K가 1이 될 차례입니다.  

### K = 1
K가 1이라면, 삽입정렬과 다를 것이 없습니다. 그렇기에, 
| =  | =  |  = | =  | =  |  = | =  |  = |  = | =  | = |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|  0| 1  |  3 |  4 | 6  | 8  |  10 | 15  | 16  | 20  | 22  |

로 마무리 됩니다.

## Merge sort
머지소트는 배열을 ~~거의~~ 반으로 쪼개서 다시 결합시켜나가는 방식으로 작동합니다.
| =  | =  |  = | =  | =  |  = | =  |  = | 
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|  21| 10  |  12 |  20 | 25  | 13  |  15 | 22 |

라는 배열이 있다면 8개이기에 4-4로 쪼갭니다.

| =  | =  |  = | =  |=  | =  |  = | =  |  = | 
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|  21| 10  |  12 |  20 | | 25  | 13  |  15 | 22 |

각각을 2-2-2-2로 쪼갭니다.

| =  | = | =  |=  | =  |  = | =  |  = | =  |  = | =  |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|21|10| |12 | 20| | 25 | 13 | |15|22|

이제 모두 1-1-1-1-1-1-1-1로 쪼갭니다.

| =  | = | =  |=  | =  |  = | =  |  = | =  |  = | =  |=  |=  |=  |=  |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|21| | 10| | 12| | 20| | 25| | 13| | 15| | 22|

이제 이걸 정렬하면서 합치기 시작합니다.

| =  | = | =  |=  | =  |  = | =  |  = | =  |  = | =  |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|10|21| |12 | 20| | 13 | 25 | |15|22|

| =  | =  |  = | =  |=  | =  |  = | =  |  = | 
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|  10| 12  |  20 |  21 | | 13  | 15  |  22 | 25 |

| =  | =  |  = | =  | =  |  = | =  |  = | 
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
| 10|12|13|15|20|21|22|25|

완성됐다!
## Quick sort

매우 빠르고, 대부분의 경우에 log꼴로 떨어지는 범용적 sort방식입니다.

Pivot을 잡아 작은 값은 왼쪽으로 큰 값은 오른쪽으로 옮겨나가며 작동합니다. 이 정렬은 조금 기억해둘 것이 있는데,  

low와 high 두가지의 index 변수를 가지고 출발합니다. 
- low는 왼쪽에서 오른쪽으로 탐색해가다가 pivot보다 큰 데이터를 찾으면 멈추고,
- high는 오른쪽에서 왼쪽으로 탐색해가다가 pivot보다 작은 데이터를 찾으면 멈춥니다.
- 이때 멈춰지면 swap을 진행해 양쪽으로 분배합니다.
- 이 low와 high가 서로 엇갈릴 때까지 반복합니다.

| =  | =  |  = | =  | =  |  = | =  |  = | 
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
| 85|24|63|45|17|31|96|50|

을 정렬하고자 하고, 만약 pivot을 가장 오른쪽으로 잡는다면, 

| =  | =  |  = | =  | =  |  = | =  |  = | 
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
| 85|24|63|45|17|31|96|50|
| low|x|x|x|x|x|high|pivot|

가 됩니다. 
- low는 50보다 크기에 85에 멈춘 것이고,
- high는 50보다 크기에 이동해 31에서 멈추게 됩니다.

| =  | =  |  = | =  | =  |  = | =  |  = | 
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
| 85|24|63|45|17|31|96|50|
| low|x|x|x|x|high|x|pivot|

이러면, swap을 진행하며 low와 high모두 이동시킵니다.

| =  | =  |  = | =  | =  |  = | =  |  = | 
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
| 31|24|63|45|17|85|96|50|
| x|low|x|x|high|x|x|pivot|

- low는 24이기에 63까지 이동해 멈추고
- high는 17이기에 가만히 있습니다.

| =  | =  |  = | =  | =  |  = | =  |  = | 
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
| 31|24|63|45|17|85|96|50|
| x|x|low|x|high|x|x|pivot|

swap 진행

| =  | =  |  = | =  | =  |  = | =  |  = | 
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
| 31|24|17|45|63|85|96|50|
| x|x|x|low|x|x|x|pivot|
| x|x|x|high|x|x|x|pivot|

이제 low와 high가 겹치게 됩니다.
이때, 45는 50보다 작기에, low가 이동합니다.

| =  | =  |  = | =  | =  |  = | =  |  = | 
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
| 31|24|17|45|63|85|96|50|
| x|x|x|x|low|x|x|pivot|
| x|x|x|high|x|x|x|pivot|

low와 high가 엇갈렸기에 low와 pivot을 바꿉니다.

| =  | =  |  = | =  | =  |  = | =  |  = | 
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
| 31|24|17|45|50|85|96|63|

이제 pivot이였던 50의 위치는 정해진 것이기 때문에 이를 `31~45`까지, `85~63`까지 다시 Quick sort를 진행합니다. 이를 반복하면 정렬이 완료되게 됩니다.

## Radix sort
Radix sort는 Non Comparison based Sorting Algorithm입니다. 비교를 하지 않고 자릿수를 봐서 정렬을 해냅니다. 이때 1의자리부터 봐가면서 정렬을 시키는데, 1의 자리는 `0~9`일 테니, (10진수라면) 1의자리만 봐서 `0~9`까지 모두 넣고, 그 다음 10의 자리를 1의자리 정렬이 완료된 순서대로 다시 넣고, 100의 자리 1000의 자리... 계속 반복해 마지막 자리에서 순서대로 위부터 차례대로 읽기만 하면 sort가 완료됩니다.


## Closing
이상으로 기본적인 sorting 알고리즘은 거의 다 알아봤습니다. 다음 글에서는 Heap에 대해 정리하고 Heap정렬까지 다루도록 하겠습니다. 