---
title: "Data Structure: Sorting"
description: "Process of arranging items or elements in a particular order or sequence."
date: "2023-05-26"
tags: ['data-structure']
---
## Sorting
이 글에서는 대략 9개 정도의 Sorting알고리즘에 대해 다루겠습니다. 각각 
- Binary tree sort
- Bubble sort
- Insertion sort
- Selection sort
- Shell sort
- Quick sort
- Merge sort
- Heap sort
- Radix sort  

입니다.

## Binary tree sort
Binary Tree를 그대로 사용하는 것입니다. LNR순서로 순회한다면, 증가 순서로 나오게 될 것이고, RNL순서로 순회한다면 감소순서로 나오게 될 것입니다. 예시로 한 Binary Tree를 들고 오자면, 

<p align="center">
<img src="https://github.com/shiueo/shiueo/blob/main/web/public/Binary_tree_v2.jpg?raw=true"/><br/>
from <a href="https://www.geeksforgeeks.org">geeksforgeeks</a>
</p>

LNR: 4 5 8 11 12 17 18  
RNL: 18 17 12 8 5 4  
순으로 잘 정렬되어 나오는 것을 알 수 있습니다.

## Bubble sort
Bubble sort는 인접한 두개의 원소를 검사하여서 큰 것과의 위치를 swap, 이걸 반복해 가장 큰 원소를 뒤에다 보내놓으면서 정렬하는 방법이다. 
<p align="center">
<img src="https://github.com/shiueo/shiueo/blob/main/web/public/bubble_sort.gif?raw=true"/><br/>
</p>

Bubble sort는 이렇게 n개의 원소를 정렬한다 하면 n번부터 1번까지 1씩 줄어들며 비교를 해내야 하고 이를 결국 n번 반복해내야 하기 때문에 **Big-O Notation**으로 봤을 때, $O(N^2)$인 것을 알 수 있다.

## Insertion sort
Insertion sort는 두번째 값부터 시작해서 그 앞자리것들과 자신을 비교해 만약 자신이 더 작다면 앞자리의 작았던 원소앞에 자신을 밀어넣는 방식으로 진행된다. 

<p align="center">
<img src="https://github.com/shiueo/shiueo/blob/main/web/public/insertion_sort.gif?raw=true"/><br/>
</p>

## Selection sort
Selection sort는 가장 작은 값부터 앞으로 놓겠다는 정렬이다. 첫번째 값을 잡고 뒷번 인덱스를 전부 가본 다음 가장 작은 값을 앞으로 끌어와 교환시킨다.

<p align="center">
<img src="https://github.com/shiueo/shiueo/blob/main/web/public/selection_sort.gif?raw=true"/><br/>
</p>

## Shell sort
Shell sort는 삽입정렬을 보완해낸 알고리즘이다. 간격을 설정해놓고 이동을 하는데, 이 간격을 $k$라고 한다면, 한번 회전시마다 이를 절반으로 줄여낸다. (물론 자신이 그 수를 정해버려도 된다.) 이때 간격이 홀수면 더 좋기 때문에 반으로 나눠서 홀수에 가까운 쪽으로 보내도록 한다.

어떤 방식으로 작동하냐면  
| =  | =  |  = | =  | =  |  = | =  |  = |  = | =  | = |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|  10| 8  |  6 |  20 | 4  | 3  |  22 | 1  | 0  | 15  | 16  |

이라는 배열이 있다고 해보면,  


### K = 5
| =  | =  |  = | =  | =  |  = | =  |  = |  = | =  | = |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|  10|   |   |   |   | 3  |   |   |   |   | 16  |
|   | 8  |   |   |   |   | 22  |   |   |   |   |  |
|   |   |  6 |   |   |   |   |   1|   |   |   | |
|   |   |   |  20 |   |   |   |   |  0 |   |   |  |
|   |   |   |   | 4  |   |   |   |   |   15|   | |

5칸씩 밀려서 값들이 들어가게 한 뒤,

같은 vertical line에 있는 값들을 삽입정렬 시킨다.

| =  | =  |  = | =  | =  |  = | =  |  = |  = | =  | = |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|  3|   |   |   |   | 10  |   |   |   |   | 16  |
|   | 8  |   |   |   |   | 22  |   |   |   |   |  |
|   |   |  1 |   |   |   |   |   6|   |   |   | |
|   |   |   |  0 |   |   |   |   |  20 |   |   |  |
|   |   |   |   | 4  |   |   |   |   |   15|   | |

그 후에 이를 다시 바닥으로 눌러내려주면
| =  | =  |  = | =  | =  |  = | =  |  = |  = | =  | = |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|  3| 8  |  1 |  0 | 4  | 10  |  22 | 6  | 20  | 15  | 16  |

가 된다. 이제 이게 1회전 끝이다. 그 다음 K=3이다.

### K = 3
| =  | =  |  = | =  | =  |  = | =  |  = |  = | =  | = |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|  3|   |   |  0 |   |   | 22  |   |   |  15 |
|   | 8  |   |   | 4  |   |   |  6 |   |   |  16 |
|   |   |  1 |   |   |  10 |   |   | 20  |   |   |

이걸 다시 삽입정렬 하고,

| =  | =  |  = | =  | =  |  = | =  |  = |  = | =  | = |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|  0|   |   |  3 |   |   | 15  |   |   |  22 |
|   | 4  |   |   | 6  |   |   |  8 |   |   |  16 |
|   |   |  1 |   |   |  10 |   |   | 20  |   |   |

찍어 누른다.

| =  | =  |  = | =  | =  |  = | =  |  = |  = | =  | = |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|  0| 4  |  1 |  3 | 6  | 10  |  15 | 8  | 20  | 22  | 16  |

이제 K가 1이 될 차례이다.  

### K = 1
K가 1이라면, 삽입정렬과 다를 것이 없다. 그렇기에, 
| =  | =  |  = | =  | =  |  = | =  |  = |  = | =  | = |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|  0| 1  |  3 |  4 | 6  | 8  |  10 | 15  | 16  | 20  | 22  |

로 마무리 된다.

## Merge sort
머지소트는 배열을 ~~거의~~ 반으로 쪼개서 다시 결합시켜나가는 방식으로 작동한다.
| =  | =  |  = | =  | =  |  = | =  |  = | 
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|  21| 10  |  12 |  20 | 25  | 13  |  15 | 22 |

라는 배열이 있다면 8개이기에 4-4로 쪼갠다.

| =  | =  |  = | =  |=  | =  |  = | =  |  = | 
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|  21| 10  |  12 |  20 | | 25  | 13  |  15 | 22 |

각각을 2-2-2-2로 쪼갠다.

| =  | = | =  |=  | =  |  = | =  |  = | =  |  = | =  |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|21|10| |12 | 20| | 25 | 13 | |15|22|

이제 모두 1-1-1-1-1-1-1-1로 쪼갠다.

| =  | = | =  |=  | =  |  = | =  |  = | =  |  = | =  |=  |=  |=  |=  |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|21| | 10| | 12| | 20| | 25| | 13| | 15| | 22|

이제 이걸 정렬하면서 합치기 시작한다.

| =  | = | =  |=  | =  |  = | =  |  = | =  |  = | =  |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|10|21| |12 | 20| | 13 | 25 | |15|22|

| =  | =  |  = | =  |=  | =  |  = | =  |  = | 
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|  10| 12  |  20 |  21 | | 13  | 15  |  22 | 25 |

| =  | =  |  = | =  | =  |  = | =  |  = | 
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
| 10|12|13|15|20|21|22|25|

완성됐다!
## Quick sort

매우 빠르고, 대부분의 경우에 log꼴로 떨어지는 범용적 sort방식이다.

Pivot을 잡아 작은 값은 왼쪽으로 큰 값은 오른쪽으로 옮겨나가며 작동한다. 이 정렬은 조금 기억해둘 것이 있는데,  

low와 high 두가지의 index 변수를 가지고 출발한다. 
- low는 왼쪽에서 오른쪽으로 탐색해가다가 pivot보다 큰 데이터를 찾으면 멈추고,
- high는 오른쪽에서 왼쪽으로 탐색해가다가 pivot보다 작은 데이터를 찾으면 멈춘다.
- 이때 멈춰지면 swap을 진행해 양쪽으로 분배한다.
- 이 low와 high가 서로 엇갈릴 때까지 반복한다.